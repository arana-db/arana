// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/dubbogo/arana/pkg/proto (interfaces: Rows,VConn,MixinResult,Plan,Optimizer)

// Package testdata is a generated GoMock package.
package testdata

import (
	context "context"
	reflect "reflect"
)

import (
	proto "github.com/dubbogo/arana/pkg/proto"

	gomock "github.com/golang/mock/gomock"
)

// MockRows is a mock of Rows interface.
type MockRows struct {
	ctrl     *gomock.Controller
	recorder *MockRowsMockRecorder
}

// MockRowsMockRecorder is the mock recorder for MockRows.
type MockRowsMockRecorder struct {
	mock *MockRows
}

// NewMockRows creates a new mock instance.
func NewMockRows(ctrl *gomock.Controller) *MockRows {
	mock := &MockRows{ctrl: ctrl}
	mock.recorder = &MockRowsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRows) EXPECT() *MockRowsMockRecorder {
	return m.recorder
}

// Next mocks base method.
func (m *MockRows) Next() proto.Row {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(proto.Row)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockRowsMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockRows)(nil).Next))
}

// MockVConn is a mock of VConn interface.
type MockVConn struct {
	ctrl     *gomock.Controller
	recorder *MockVConnMockRecorder
}

// MockVConnMockRecorder is the mock recorder for MockVConn.
type MockVConnMockRecorder struct {
	mock *MockVConn
}

// NewMockVConn creates a new mock instance.
func NewMockVConn(ctrl *gomock.Controller) *MockVConn {
	mock := &MockVConn{ctrl: ctrl}
	mock.recorder = &MockVConnMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVConn) EXPECT() *MockVConnMockRecorder {
	return m.recorder
}

// Exec mocks base method.
func (m *MockVConn) Exec(arg0 context.Context, arg1, arg2 string, arg3 ...interface{}) (proto.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(proto.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockVConnMockRecorder) Exec(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockVConn)(nil).Exec), varargs...)
}

// Query mocks base method.
func (m *MockVConn) Query(arg0 context.Context, arg1, arg2 string, arg3 ...interface{}) (proto.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(proto.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockVConnMockRecorder) Query(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockVConn)(nil).Query), varargs...)
}

// MockMixinResult is a mock of MixinResult interface.
type MockMixinResult struct {
	ctrl     *gomock.Controller
	recorder *MockMixinResultMockRecorder
}

// MockMixinResultMockRecorder is the mock recorder for MockMixinResult.
type MockMixinResultMockRecorder struct {
	mock *MockMixinResult
}

// NewMockMixinResult creates a new mock instance.
func NewMockMixinResult(ctrl *gomock.Controller) *MockMixinResult {
	mock := &MockMixinResult{ctrl: ctrl}
	mock.recorder = &MockMixinResultMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMixinResult) EXPECT() *MockMixinResultMockRecorder {
	return m.recorder
}

// LastInsertId mocks base method.
func (m *MockMixinResult) LastInsertId() (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastInsertId")
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LastInsertId indicates an expected call of LastInsertId.
func (mr *MockMixinResultMockRecorder) LastInsertId() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastInsertId", reflect.TypeOf((*MockMixinResult)(nil).LastInsertId))
}

// Next mocks base method.
func (m *MockMixinResult) Next() proto.Row {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(proto.Row)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockMixinResultMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockMixinResult)(nil).Next))
}

// RowsAffected mocks base method.
func (m *MockMixinResult) RowsAffected() (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RowsAffected")
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RowsAffected indicates an expected call of RowsAffected.
func (mr *MockMixinResultMockRecorder) RowsAffected() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RowsAffected", reflect.TypeOf((*MockMixinResult)(nil).RowsAffected))
}

// MockPlan is a mock of Plan interface.
type MockPlan struct {
	ctrl     *gomock.Controller
	recorder *MockPlanMockRecorder
}

// MockPlanMockRecorder is the mock recorder for MockPlan.
type MockPlanMockRecorder struct {
	mock *MockPlan
}

// NewMockPlan creates a new mock instance.
func NewMockPlan(ctrl *gomock.Controller) *MockPlan {
	mock := &MockPlan{ctrl: ctrl}
	mock.recorder = &MockPlanMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPlan) EXPECT() *MockPlanMockRecorder {
	return m.recorder
}

// ExecIn mocks base method.
func (m *MockPlan) ExecIn(arg0 context.Context, arg1 proto.VConn) (proto.MixinResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecIn", arg0, arg1)
	ret0, _ := ret[0].(proto.MixinResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecIn indicates an expected call of ExecIn.
func (mr *MockPlanMockRecorder) ExecIn(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecIn", reflect.TypeOf((*MockPlan)(nil).ExecIn), arg0, arg1)
}

// Type mocks base method.
func (m *MockPlan) Type() proto.PlanType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(proto.PlanType)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockPlanMockRecorder) Type() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockPlan)(nil).Type))
}

// MockOptimizer is a mock of Optimizer interface.
type MockOptimizer struct {
	ctrl     *gomock.Controller
	recorder *MockOptimizerMockRecorder
}

// MockOptimizerMockRecorder is the mock recorder for MockOptimizer.
type MockOptimizerMockRecorder struct {
	mock *MockOptimizer
}

// NewMockOptimizer creates a new mock instance.
func NewMockOptimizer(ctrl *gomock.Controller) *MockOptimizer {
	mock := &MockOptimizer{ctrl: ctrl}
	mock.recorder = &MockOptimizerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOptimizer) EXPECT() *MockOptimizerMockRecorder {
	return m.recorder
}

// Optimize mocks base method.
func (m *MockOptimizer) Optimize(arg0 context.Context, arg1 string, arg2 ...interface{}) (proto.Plan, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Optimize", varargs...)
	ret0, _ := ret[0].(proto.Plan)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Optimize indicates an expected call of Optimize.
func (mr *MockOptimizerMockRecorder) Optimize(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Optimize", reflect.TypeOf((*MockOptimizer)(nil).Optimize), varargs...)
}
